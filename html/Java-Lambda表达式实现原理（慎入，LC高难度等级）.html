<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
<h1>Java Lambda表达式实现原理（慎入，LC高难度等级）</h1>
<p>2022-05-06T12:15:41.349+0800</p>
<p><p>Lambda表达式，通常用于函数式编程，我们通常只关注数据流本身的处理，并不需要详细设计整个面向对象的框架：OOA、OOD、OOP。如Java的Stream Java SE提供的流式处理框架，我们只需要将目标放在如何处理数据流，对数据流进行ETL得到最终的结果即可，这时我们可以利用Lambda表达式来代替Java 面向对象编写代码。而本文就是想要看看Lamda表达式它的实现过程到底是什么样的。</p>
<p><strong>Java 语言层面</strong></p>
<p>由于我们的关注点在于Lambda表达式的实现原理，并不是要看它怎么用，所以我们只需要给出一个简单的用例描述即可。此时我们用以下代码来生成要给Lambda表达式。我们创建了一个Runnable hello 对象，调用其run方法，而方法的实现体使用Lambda表达式风格来编写（ () -&gt; System.out.println("hello") ）。通过Java 语言的特性，我们需要解决的问题：</p>
<ol>
 <li>System.out.println("hello") Lambda表达式实现体的字节码在哪里？</li>
 <li>Runnable hello 这个Runnable的对象是如何生成的？</li>
</ol>
<p><span style="color: rgb(200, 143, 208);">public</span> <span style="color: rgb(200, 143, 208);">class</span> <span style="color: rgb(141, 141, 240);">Demo</span> {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">public</span> <span style="color: rgb(200, 143, 208);">static</span> <span style="color: rgb(28, 198, 133);">void</span> <span style="color: rgb(184, 191, 198);">main</span>(<span style="color: rgb(28, 198, 133);">String</span>[] <span style="color: rgb(184, 191, 198);">args</span>) <span style="color: rgb(200, 143, 208);">throws</span> <span style="color: rgb(184, 191, 198);">Exception</span> {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Runnable</span> <span style="color: rgb(184, 191, 198);">hello</span> <span style="color: rgb(184, 191, 198);">=</span> () <span style="color: rgb(184, 191, 198);">-&gt;</span> <span style="color: rgb(184, 191, 198);">System</span>.<span style="color: rgb(184, 191, 198);">out</span>.<span style="color: rgb(184, 191, 198);">println</span>(<span style="color: rgb(210, 107, 107);">"hello"</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">hello</span>.<span style="color: rgb(184, 191, 198);">run</span>();</p>
<p>&nbsp;}</p>
<p>}</p>
<p><strong>字节码层面</strong></p>
<p>我们想要研究Lambda表达式，那只能看字节码了，字节码是Java语言通过Javac的编译器 进行 AST 的生成，转为的IR中间语言，所以研究字节码 那就 比Java语言盲猜更进一步。通过javap 反编译Demo.class之后，我们得到如下信息：</p>
<ol>
 <li>在Demo.class 中，由编译器生成了一个 private static void lambda$main$0() 私有静态方法，由于该方法为私有且静态，所以我们完全可以推理得出：该方法必须在Demo 类中访问或者它的内部类中访问，而且可以直接用类名.lambda$main$0来直接访问（论据）</li>
 <li>在Main方法的字节码中，我们看到由于Java调用方法需要对象，所以我们需要产生一个Runnable实现类的对象（因为Runnable是接口呀），那么才能调用其run方法（论据）</li>
 <li>由字节码顺序：invokedynamic、astore_1、aload_1、invokeinterface，我们得出：astore适用于存储对象的（JVM规范定义a就是对象引用）、invokeinterface将会使用invokedynamic返回的对象来调用run方法（论据）</li>
</ol>
<p>通过上述论据得知：研究Lambda表达式的原理，需要研究invokedynamic字节码的处理过程。而又由于第一个论据，我们不妨推测一下：JVM 创建了一个静态的Demo 内部类，使用它实现了Runnable接口，然后再其中调用了 lambda$main$0() 私有静态方法。</p>
<p>通过字节码我们又了解到在常量池中，存在如下我们之前不了解的常量池信息：</p>
<ol>
 <li>什么是InvokeDynamic？</li>
 <li>什么是MethodHandle？</li>
 <li>什么是MethodType？</li>
</ol>
<p>在字节码的最后编译器加上的：BootstrapMethods也不清楚为何物。</p>
<p>Classfile /C:/Users/hundun/Desktop/java/Demo.class</p>
<p>Compiled from "Demo.java"</p>
<p>public class Demo</p>
<p>Constant pool:</p>
<p>&nbsp;#1 = Methodref&nbsp;&nbsp;&nbsp;&nbsp;#8.#18&nbsp;&nbsp;&nbsp;&nbsp;// java/lang/Object."&lt;init&gt;":()V</p>
<p>&nbsp;#2 = InvokeDynamic&nbsp;&nbsp;#0:#23&nbsp;&nbsp;&nbsp;&nbsp;// #0:run:()Ljava/lang/Runnable;</p>
<p>&nbsp;#3 = InterfaceMethodref #24.#25&nbsp;&nbsp;&nbsp;// java/lang/Runnable.run:()V</p>
<p>#19 = Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BootstrapMethods</p>
<p>#20 = MethodHandle&nbsp;&nbsp;&nbsp;#6:#33&nbsp;&nbsp;&nbsp;&nbsp;// invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles<span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(159, 186, 213);">Lookup</span>;<span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">String</span>;<span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodType</span>;<span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodType</span>;<span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodHandle</span>;<span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodType</span>;<span style="color: rgb(153, 153, 119);">)</span><span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">CallSite</span>;</p>
<p>#<span style="color: rgb(100, 171, 143);">21</span> = <span style="color: rgb(159, 186, 213);">MethodType</span>&nbsp;&nbsp;&nbsp;&nbsp;#<span style="color: rgb(100, 171, 143);">10</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;<span style="color: rgb(153, 153, 119);">()</span><span style="color: rgb(159, 186, 213);">V</span></p>
<p>#<span style="color: rgb(100, 171, 143);">22</span> = <span style="color: rgb(159, 186, 213);">MethodHandle</span>&nbsp;&nbsp;&nbsp;#<span style="color: rgb(100, 171, 143);">6</span>:#<span style="color: rgb(100, 171, 143);">34</span>&nbsp;&nbsp;&nbsp;&nbsp;// <span style="color: rgb(159, 186, 213);">invokestatic</span> <span style="color: rgb(159, 186, 213);">Demo</span><span style="color: red;">.</span><span style="color: rgb(159, 186, 213);">lambda</span><span style="color: rgb(200, 143, 208);">$</span>main<span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(100, 171, 143);">0</span>:<span style="color: rgb(153, 153, 119);">()</span><span style="color: rgb(159, 186, 213);">V</span></p>
<p>#<span style="color: rgb(100, 171, 143);">23</span> = <span style="color: rgb(159, 186, 213);">NameAndType</span>&nbsp;&nbsp;&nbsp;#<span style="color: rgb(100, 171, 143);">35</span>:#<span style="color: rgb(100, 171, 143);">36</span>&nbsp;&nbsp;&nbsp;// <span style="color: rgb(159, 186, 213);">run</span>:<span style="color: rgb(153, 153, 119);">()</span><span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">Runnable</span>;</p>
<p>#<span style="color: rgb(100, 171, 143);">24</span> = <span style="color: rgb(159, 186, 213);">Class</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<span style="color: rgb(100, 171, 143);">37</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <span style="color: rgb(159, 186, 213);">java</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">Runnable</span></p>
<p>#<span style="color: rgb(100, 171, 143);">25</span> = <span style="color: rgb(159, 186, 213);">NameAndType</span>&nbsp;&nbsp;&nbsp;#<span style="color: rgb(100, 171, 143);">35</span>:#<span style="color: rgb(100, 171, 143);">10</span>&nbsp;&nbsp;&nbsp;// <span style="color: rgb(159, 186, 213);">run</span>:<span style="color: rgb(153, 153, 119);">()</span><span style="color: rgb(159, 186, 213);">V</span></p>
<p>#<span style="color: rgb(100, 171, 143);">33</span> = <span style="color: rgb(159, 186, 213);">Methodref</span>&nbsp;&nbsp;&nbsp;&nbsp;#<span style="color: rgb(100, 171, 143);">44.</span>#<span style="color: rgb(100, 171, 143);">45</span>&nbsp;&nbsp;&nbsp;// <span style="color: rgb(159, 186, 213);">java</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">LambdaMetafactory</span><span style="color: red;">.</span><span style="color: rgb(159, 186, 213);">metafactory</span>:<span style="color: rgb(153, 153, 119);">(</span><span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodHandles</span><span style="color: rgb(200, 143, 208);">$</span>Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</p>
<p>#34 = Methodref&nbsp;&nbsp;&nbsp;&nbsp;#7.#46&nbsp;&nbsp;&nbsp;&nbsp;// Demo.lambda<span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(159, 186, 213);">main</span><span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(132, 182, 203);">0</span>:()V</p>
<p>#44 = Class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// java/lang/invoke/LambdaMetafactory</p>
<p>#45 = NameAndType&nbsp;&nbsp;&nbsp;#48:#52&nbsp;&nbsp;&nbsp;// metafactory:(Ljava/lang/invoke/MethodHandles<span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(159, 186, 213);">Lookup</span>;<span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">String</span>;<span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodType</span>;<span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodType</span>;<span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodHandle</span>;<span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodType</span>;<span style="color: rgb(153, 153, 119);">)</span><span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">CallSite</span>;</p>
<p>#<span style="color: rgb(100, 171, 143);">46</span> = <span style="color: rgb(159, 186, 213);">NameAndType</span>&nbsp;&nbsp;&nbsp;#<span style="color: rgb(100, 171, 143);">15</span>:#<span style="color: rgb(100, 171, 143);">10</span>&nbsp;&nbsp;&nbsp;// <span style="color: rgb(159, 186, 213);">lambda</span><span style="color: rgb(200, 143, 208);">$</span>main<span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(100, 171, 143);">0</span>:<span style="color: rgb(153, 153, 119);">()</span><span style="color: rgb(159, 186, 213);">V</span></p>
<p>#<span style="color: rgb(100, 171, 143);">49</span> = <span style="color: rgb(159, 186, 213);">Class</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<span style="color: rgb(100, 171, 143);">54</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <span style="color: rgb(159, 186, 213);">java</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodHandles</span><span style="color: rgb(200, 143, 208);">$</span>Lookup</p>
<p>#53 = Class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// java/lang/invoke/MethodHandles</p>
<p>#54 = Utf8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java/lang/invoke/MethodHandles<span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(159, 186, 213);">Lookup</span></p>
<p>#<span style="color: rgb(100, 171, 143);">55</span> = <span style="color: rgb(159, 186, 213);">Utf</span><span style="color: rgb(100, 171, 143);">8</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(159, 186, 213);">java</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodHandles</span></p>
<p><span style="color: rgb(153, 153, 119);">{</span></p>
<p>&nbsp;<span style="color: rgb(159, 186, 213);">public</span> <span style="color: rgb(159, 186, 213);">static</span> <span style="color: rgb(159, 186, 213);">void</span> <span style="color: rgb(159, 186, 213);">main</span><span style="color: rgb(153, 153, 119);">(</span><span style="color: rgb(159, 186, 213);">java</span><span style="color: red;">.</span><span style="color: rgb(159, 186, 213);">lang</span><span style="color: red;">.</span><span style="color: rgb(159, 186, 213);">String</span><span style="color: rgb(153, 153, 119);">[])</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(159, 186, 213);">descriptor</span>: <span style="color: rgb(153, 153, 119);">([</span><span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">String</span>;<span style="color: rgb(153, 153, 119);">)</span><span style="color: rgb(159, 186, 213);">V</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(159, 186, 213);">flags</span>: <span style="color: rgb(159, 186, 213);">ACC</span><span style="color: rgb(125, 244, 106);">_</span><span style="color: rgb(159, 186, 213);">PUBLIC</span>, <span style="color: rgb(159, 186, 213);">ACC</span><span style="color: rgb(125, 244, 106);">_</span><span style="color: rgb(159, 186, 213);">STATIC</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(159, 186, 213);">Code</span>:</p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(159, 186, 213);">stack</span>=<span style="color: rgb(100, 171, 143);">1</span>, <span style="color: rgb(159, 186, 213);">locals</span>=<span style="color: rgb(100, 171, 143);">2</span>, <span style="color: rgb(159, 186, 213);">args</span><span style="color: rgb(125, 244, 106);">_</span><span style="color: rgb(159, 186, 213);">size</span>=<span style="color: rgb(100, 171, 143);">1</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(100, 171, 143);">0</span>: <span style="color: rgb(159, 186, 213);">invokedynamic</span> #<span style="color: rgb(100, 171, 143);">2</span>,&nbsp;<span style="color: rgb(100, 171, 143);">0</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <span style="color: rgb(159, 186, 213);">InvokeDynamic</span> #<span style="color: rgb(100, 171, 143);">0</span>:<span style="color: rgb(159, 186, 213);">run</span>:<span style="color: rgb(153, 153, 119);">()</span><span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">Runnable</span>;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(100, 171, 143);">5</span>: <span style="color: rgb(159, 186, 213);">astore</span><span style="color: rgb(125, 244, 106);">_</span><span style="color: rgb(100, 171, 143);">1</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(100, 171, 143);">6</span>: <span style="color: rgb(159, 186, 213);">aload</span><span style="color: rgb(125, 244, 106);">_</span><span style="color: rgb(100, 171, 143);">1</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(100, 171, 143);">7</span>: <span style="color: rgb(159, 186, 213);">invokeinterface</span> #<span style="color: rgb(100, 171, 143);">3</span>,&nbsp;<span style="color: rgb(100, 171, 143);">1</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <span style="color: rgb(159, 186, 213);">InterfaceMethod</span> <span style="color: rgb(159, 186, 213);">java</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">Runnable</span><span style="color: red;">.</span><span style="color: rgb(159, 186, 213);">run</span>:<span style="color: rgb(153, 153, 119);">()</span><span style="color: rgb(159, 186, 213);">V</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(100, 171, 143);">12</span>: <span style="color: rgb(159, 186, 213);">return</span></p>
<p>​</p>
<p>private static void lambda<span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(159, 186, 213);">main</span><span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(132, 182, 203);">0</span>();</p>
<p>&nbsp;descriptor: ()V</p>
<p>&nbsp;flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</p>
<p>&nbsp;Code:</p>
<p>&nbsp;&nbsp;stack=2, locals=0, args_size=0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;0: getstatic&nbsp;&nbsp;#4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;3: ldc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// String hello</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;5: invokevirtual #6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;8: return</p>
<p><span style="color: red;">}</span></p>
<p>InnerClasses:</p>
<p>&nbsp;&nbsp;public static final #50= #49 of #53; //Lookup=class java/lang/invoke/MethodHandles<span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(159, 186, 213);">Lookup</span> <span style="color: rgb(159, 186, 213);">of</span> <span style="color: rgb(159, 186, 213);">class</span> <span style="color: rgb(159, 186, 213);">java</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodHandles</span></p>
<p><span style="color: rgb(159, 186, 213);">BootstrapMethods</span>:</p>
<p>&nbsp;<span style="color: rgb(100, 171, 143);">0</span>: #<span style="color: rgb(100, 171, 143);">20</span> <span style="color: rgb(159, 186, 213);">invokestatic</span> <span style="color: rgb(159, 186, 213);">java</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">LambdaMetafactory</span><span style="color: red;">.</span><span style="color: rgb(159, 186, 213);">metafactory</span>:<span style="color: rgb(153, 153, 119);">(</span><span style="color: rgb(159, 186, 213);">Ljava</span>/<span style="color: rgb(159, 186, 213);">lang</span>/<span style="color: rgb(159, 186, 213);">invoke</span>/<span style="color: rgb(159, 186, 213);">MethodHandles</span><span style="color: rgb(200, 143, 208);">$</span>Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</p>
<p>&nbsp;Method arguments:</p>
<p>&nbsp;&nbsp;#21 ()V</p>
<p>&nbsp;&nbsp;#22 invokestatic Demo.lambda<span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(159, 186, 213);">main</span><span style="color: rgb(200, 143, 208);">$</span><span style="color: rgb(132, 182, 203);">0</span>:()V</p>
<p>&nbsp;&nbsp;#21 ()V</p>
<p><strong>JVM规范层面</strong></p>
<p><strong>InvokeDynamic</strong></p>
<p>在上述字节中：invokedynamic #2, 0 // InvokeDynamic #0:run:()Ljava/lang/Runnable; 指令引用了2常量池：#2 = InvokeDynamic #0:#23 // #0:run:()Ljava/lang/Runnable; 那么该常量池定义这个东西用来干啥的？来看如下JVM规范手册对该常量的池的描述。我们得知：CONSTANT_InvokeDynamic_info常量池用于描述 invokedynamic 指令所调用的 bootstrap_method 的信息。</p>
<p>The CONSTANT_InvokeDynamic_info structure is used by an invokedynamic</p>
<p>instruction (§invokedynamic) to specify a bootstrap method, the dynamic</p>
<p>invocation name, the argument and return types of the call, and optionally, a</p>
<p>sequence of additional constants called static arguments to the bootstrap method.</p>
<p>译：CONSTANT_InvokeDynamic_info结构中的内容将会被 invokedynamic 字节码指令所使用来调用一个初始化方法，指明了：动态调用名、参数、返回类型，并且可选的可以增加一些额外描述静态常量参数的信息</p>
<p>CONSTANT_InvokeDynamic_info <span style="color: rgb(153, 153, 119);">{</span></p>
<p>u1 tag;</p>
<p>u2 bootstrap_method_attr_index; // bootstrap_methods 的索引值</p>
<p>u2 name_and_type_index;</p>
<p><span style="color: rgb(153, 153, 119);">}</span></p>
<p><strong>MethodHandle</strong></p>
<p>在上述字节中： 0: #20 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; 中 BootstrapMethods 描述的信息中使用了#20常量池，MethodHandle #6:#33 // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; 。由JVM规范手册指出，该常量池描述了一个方法的句柄，由于 在 Lambda表达式的原理中使用的类型为6，所以指向CONSTANT_Methodref_info常量池，描述了调用的方法签名（所属类 + 参数定义 + 返回值）（论据）。</p>
<p>The CONSTANT_MethodHandle_info structure is used to represent a method handle:</p>
<p>译：CONSTANT_MethodHandle_info常量池用于表示一个方法的句柄</p>
<p>CONSTANT_MethodHandle_info <span style="color: rgb(153, 153, 119);">{</span></p>
<p>u1 tag;</p>
<p>u1 reference_kind; // 表示方法句柄的种类，取值为 1 - 9</p>
<p>u2 reference_index; // 根据 reference_kind 的取值来指向不同的常量池：CONSTANT_Fieldref_info（reference_kind取值：1-4）、CONSTANT_Methodref_info（reference_kind取值：5 或 8）、CONSTANT_Methodref_info（reference_kind取值：6 或 7）、CONSTANT_InterfaceMethodref_info（reference_kind取值：9）</p>
<p><span style="color: rgb(153, 153, 119);">}</span></p>
<p><strong>MethodType</strong></p>
<p>在上述字节中在</p>
<p>Method arguments: #21 ()V #22 invokestatic Demo.lambda$main$0:()V #21 ()V</p>
<p>中使用了MethodType #10 // ()V来表示方法的参数。</p>
<p>The CONSTANT_MethodType_info structure is used to represent a method type:</p>
<p>译：CONSTANT_MethodType_info适用于表示要给方法类型</p>
<p>CONSTANT_MethodType_info <span style="color: rgb(153, 153, 119);">{</span></p>
<p>u1 tag;</p>
<p>u2 descriptor_index; // 指向 CONSTANT_Utf8_info 符号索引</p>
<p><span style="color: rgb(153, 153, 119);">}</span></p>
<p><strong>BootstrapMethods</strong></p>
<p>在上述字节码层面中，我们使用了BootstrapMethods:来描述初始化方法。通过JVM手册描述，该属性用于表示：BootstrapMethods属性记录了被invokedynamic字节码所使用的bootstrap方法信息。</p>
<p>The BootstrapMethods attribute is a variable-length attribute in the attributes</p>
<p>table of a ClassFile structure (§4.1). The BootstrapMethods attribute</p>
<p>records bootstrap method specifiers referenced by invokedynamic instructions</p>
<p>(§invokedynamic).</p>
<p>There must be exactly one BootstrapMethods attribute in the attributes table of</p>
<p>a ClassFile structure if the constant_pool table of the ClassFile structure has</p>
<p>at least one CONSTANT_InvokeDynamic_info entry (§4.4.10).</p>
<p>There may be at most one BootstrapMethods attribute in the attributes table of</p>
<p>a ClassFile structure.</p>
<p>The BootstrapMethods attribute has the following format:</p>
<p>译：BootstrapMethods属性是一个可变长度的属性。BootstrapMethods属性记录了被invokedynamic字节码所使用的bootstrap方法信息。如果字节码常量池中存在 CONSTANT_InvokeDynamic_info 常量池，那么必须存在一个 BootstrapMethods 的属性。</p>
<p>BootstrapMethods_attribute <span style="color: rgb(153, 153, 119);">{</span></p>
<p>u2 attribute_name_index;</p>
<p>u4 attribute_length;</p>
<p>u2 num_bootstrap_methods; // BootStrap方法个数</p>
<p><span style="color: rgb(153, 153, 119);">{</span> u2 bootstrap_method_ref; // 每个BootStrap方法的描述信息</p>
<p>u2 num_bootstrap_arguments;</p>
<p>u2 bootstrap_arguments<span style="color: rgb(153, 153, 119);">[</span>num_bootstrap_arguments<span style="color: rgb(153, 153, 119);">]</span>;</p>
<p><span style="color: rgb(153, 153, 119);">}</span> bootstrap_methods<span style="color: rgb(153, 153, 119);">[</span>num_bootstrap_methods<span style="color: rgb(153, 153, 119);">]</span>;</p>
<p><span style="color: rgb(153, 153, 119);">}</span></p>
<p><strong>invokedynamic 字节码</strong></p>
<p>该字节码用于提供给JVM动态调用方法的能力，也即将实际调用方法交给应用程序在BootstrapMethod中定义使用。可以看到它的操作数为一个指向InvokeDynamic常量池的下标，同时InvokeDynamic又指向了BootstrapMethod属性中方法描述。至此，我们可以猜测：invokedynamic 将会调用BootstrapMethod方法获取某个对象。我们从JVM规范手册中看到该对象为call site，表示一个调用点，而实际调用方法，应该为实现Runnable接口的类的run方法。</p>
<p>Each specific lexical occurrence of an invokedynamic instruction is called a dynamic call site.</p>
<p>First, the unsigned indexbyte1 and indexbyte2 are used to construct an index into the run-time constant pool of the current class (§2.6), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2.</p>
<p>​</p>
<p>译：invokedynamic 字节码调用方法称为动态调用 call site。 首先，无符号 indexbyte1 和indexbyte2 索引值被用来指向当前类的运行时常量池，其中指向常量索引的值计算方式为：(indexbyte1 &lt;&lt; 8) | indexbyte2。</p>
<p>​</p>
<p>The run-time constant pool item at that index must be a symbolic reference to a call site specifier (§5.1). The values of the third and fourth operand bytes must always be zero.The call site specifier is resolved (§5.4.3.6) for this specific dynamic call site to obtain a reference to a java.lang.invoke.MethodHandle instance that will serve as the bootstrap method, a reference to a java.lang.invoke.MethodType instance, and references to static arguments.</p>
<p>​</p>
<p>译：该索引指向的运行时常量池必须是对 call site 描述符的符号引用。 第三和第四个操作数的值必须为零。 call site描述符在解析时，将使这个特定的 call site 获得对 java.lang.invoke.MethodHandle 实例的引用 (用作引导方法)，对java.lang.invoke.MethodType实例的引用，以及对静态参数的引用。&nbsp;</p>
<p><strong>JVM 实现层面</strong></p>
<p><strong>invokedynamic 字节码执行过程</strong></p>
<p><span style="color: rgb(184, 191, 198);">CASE</span>(<span style="color: rgb(184, 191, 198);">_invokedynamic</span>): {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">u4</span> <span style="color: rgb(184, 191, 198);">index</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">Bytes::get_native_u4</span>(<span style="color: rgb(184, 191, 198);">pc+</span><span style="color: rgb(100, 171, 143);">1</span>); <span style="color: rgb(218, 146, 74);">// 获取指向invokedynamic常量池的索引</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">ConstantPoolCacheEntry*</span> <span style="color: rgb(184, 191, 198);">cache</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">cp-&gt;constant_pool</span>()<span style="color: rgb(184, 191, 198);">-&gt;invokedynamic_cp_cache_entry_at</span>(<span style="color: rgb(184, 191, 198);">index</span>); <span style="color: rgb(218, 146, 74);">// 获取常量池运行时信息，由于牵扯的知识太多，读者这里只需要知道CPCE表示常量池在运行时动态产生的信息即可（ConstantPool 类表示类的静态信息）</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">!</span> <span style="color: rgb(184, 191, 198);">cache-&gt;is_resolved</span>((<span style="color: rgb(184, 191, 198);">Bytecodes::Code</span>) <span style="color: rgb(184, 191, 198);">opcode</span>)) { <span style="color: rgb(218, 146, 74);">// 当前运行时信息是否已经完成解析，当然，首次第调用必定没有解析，所以这里需要调用resolve_invokedynamic解析该常量池（注意哦：字节码中的索引下标所有的都没有真实地址，这里解析就是把这些符号描述转为真实对象地址，这里也是一个重点）</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">CALL_VM</span>(<span style="color: rgb(184, 191, 198);">InterpreterRuntime::resolve_invokedynamic</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>),</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">handle_exception</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">cache</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">cp-&gt;constant_pool</span>()<span style="color: rgb(184, 191, 198);">-&gt;invokedynamic_cp_cache_entry_at</span>(<span style="color: rgb(184, 191, 198);">index</span>);</p>
<p>&nbsp;}</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Method*</span> <span style="color: rgb(184, 191, 198);">method</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">cache-&gt;f1_as_method</span>(); <span style="color: rgb(218, 146, 74);">// 从运行时信息中获取到要调用的方法指针，注意，这个方法就是包含字节码信息的执行方法</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">cache-&gt;has_appendix</span>()) { <span style="color: rgb(218, 146, 74);">// 存在appendix对象，那么将其放入操作数栈顶，调用的方法可以使用该栈顶对象</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">ConstantPool*</span> <span style="color: rgb(184, 191, 198);">constants</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">METHOD-&gt;constants</span>();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">SET_STACK_OBJECT</span>(<span style="color: rgb(184, 191, 198);">cache-&gt;appendix_if_resolved</span>(<span style="color: rgb(184, 191, 198);">constants</span>), <span style="color: rgb(100, 171, 143);">0</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MORE_STACK</span>(<span style="color: rgb(100, 171, 143);">1</span>);</p>
<p>&nbsp;}</p>
<p>&nbsp;&nbsp;<span style="color: rgb(218, 146, 74);">// 开始告诉解释器调用 Method* method</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">istate-&gt;set_msg</span>(<span style="color: rgb(184, 191, 198);">call_method</span>); <span style="color: rgb(218, 146, 74);">// 更改解释器状态：需要调用方法</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">istate-&gt;set_callee</span>(<span style="color: rgb(184, 191, 198);">method</span>);&nbsp;<span style="color: rgb(218, 146, 74);">// 调用的方法体</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">istate-&gt;set_callee_entry_point</span>(<span style="color: rgb(184, 191, 198);">method-&gt;from_interpreted_entry</span>()); <span style="color: rgb(218, 146, 74);">// 该方法的解释器入口，也即解释器需要到该入口处开始执行</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">istate-&gt;set_bcp_advance</span>(<span style="color: rgb(100, 171, 143);">5</span>); <span style="color: rgb(218, 146, 74);">// 告诉解释器执行完该方法返回时，设置当前bcp 也即 字节码指针（PC 计数器）向前跳转 5个字节，也即到astore_1 处</span></p>
<p>​</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">UPDATE_PC_AND_RETURN</span>(<span style="color: rgb(100, 171, 143);">0</span>); <span style="color: rgb(218, 146, 74);">// 返回当前方法执行，当返回后解释器将开始调用Method* method</span></p>
<p>}</p>
<p>那么，根据上述的代码，我们可以给出疑问：</p>
<ol>
 <li>InterpreterRuntime::resolve_invokedynamic 干了什么？</li>
 <li>Method* method 方法是啥？</li>
 <li>appendix 是什么对象？</li>
 <li>Method* method 方法的入口函数是什么？</li>
</ol>
<p>我们先来看resolve_invokedynamic方法。我们从代码中看到核心方法为resolve_invoke，解析完毕后，在set_dynamic_call方法将会将解析的结果与CPCE绑定，此时就完成了该字节码的所引用常量池invokedynamic 解析。</p>
<p><span style="color: rgb(184, 191, 198);">IRT_ENTRY</span>(<span style="color: rgb(28, 198, 133);">void</span>, <span style="color: rgb(184, 191, 198);">InterpreterRuntime::resolve_invokedynamic</span>(<span style="color: rgb(184, 191, 198);">JavaThread*</span> <span style="color: rgb(184, 191, 198);">thread</span>)) {</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">const</span> <span style="color: rgb(184, 191, 198);">Bytecodes::Code</span> <span style="color: rgb(184, 191, 198);">bytecode</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">Bytecodes::_invokedynamic</span>;</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 开始解析方法</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">CallInfo</span> <span style="color: rgb(184, 191, 198);">info</span>; <span style="color: rgb(218, 146, 74);">// 保存实际解析信息</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">constantPoolHandle</span> <span style="color: rgb(184, 191, 198);">pool</span>(<span style="color: rgb(184, 191, 198);">thread</span>, <span style="color: rgb(184, 191, 198);">method</span>(<span style="color: rgb(184, 191, 198);">thread</span>)<span style="color: rgb(184, 191, 198);">-&gt;constants</span>());</p>
<p>&nbsp;<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">index</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">get_index_u4</span>(<span style="color: rgb(184, 191, 198);">thread</span>, <span style="color: rgb(184, 191, 198);">bytecode</span>); <span style="color: rgb(218, 146, 74);">// 获取常量池索引下标</span></p>
<p>{</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">JvmtiHideSingleStepping</span> <span style="color: rgb(184, 191, 198);">jhss</span>(<span style="color: rgb(184, 191, 198);">thread</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">LinkResolver::resolve_invoke</span>(<span style="color: rgb(184, 191, 198);">info</span>, <span style="color: rgb(184, 191, 198);">Handle</span>(), <span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">bytecode</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>); <span style="color: rgb(218, 146, 74);">// 开始解析</span></p>
<p>}</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 解析完成后将解析后的信息保存到cp_cache_entry运行时信息中保存</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">ConstantPoolCacheEntry*</span> <span style="color: rgb(184, 191, 198);">cp_cache_entry</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">pool-&gt;invokedynamic_cp_cache_entry_at</span>(<span style="color: rgb(184, 191, 198);">index</span>);</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">cp_cache_entry-&gt;set_dynamic_call</span>(<span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(184, 191, 198);">info</span>);</p>
<p>}</p>
<p><span style="color: rgb(184, 191, 198);">IRT_END</span></p>
<p>&nbsp;&nbsp;</p>
<p><span style="color: rgb(218, 146, 74);">// 将解析后的CallInfo的信息放入cp_cache_entry对象中</span></p>
<p><span style="color: rgb(28, 198, 133);">void</span> <span style="color: rgb(141, 141, 240);">ConstantPoolCacheEntry::set_dynamic_call</span>(<span style="color: rgb(184, 191, 198);">constantPoolHandle</span> <span style="color: rgb(184, 191, 198);">cpool</span>, <span style="color: rgb(200, 143, 208);">const</span> <span style="color: rgb(184, 191, 198);">CallInfo</span> <span style="color: rgb(184, 191, 198);">&amp;call_info</span>) {</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">set_method_handle_common</span>(<span style="color: rgb(184, 191, 198);">cpool</span>, <span style="color: rgb(184, 191, 198);">Bytecodes::_invokedynamic</span>, <span style="color: rgb(184, 191, 198);">call_info</span>);</p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(218, 146, 74);">// 处理实际放入操作</span></p>
<p><span style="color: rgb(28, 198, 133);">void</span> <span style="color: rgb(141, 141, 240);">ConstantPoolCacheEntry::set_method_handle_common</span>(<span style="color: rgb(184, 191, 198);">constantPoolHandle</span> <span style="color: rgb(184, 191, 198);">cpool</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Bytecodes::Code</span> <span style="color: rgb(184, 191, 198);">invoke_code</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">const</span> <span style="color: rgb(184, 191, 198);">CallInfo</span> <span style="color: rgb(184, 191, 198);">&amp;call_info</span>) {</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">!is_f1_null</span>()) { <span style="color: rgb(218, 146, 74);">// 之前已经处理过，直接返回</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span>;</p>
<p>}</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">const</span> <span style="color: rgb(184, 191, 198);">methodHandle</span> <span style="color: rgb(184, 191, 198);">adapter</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">call_info</span>.<span style="color: rgb(184, 191, 198);">resolved_method</span>(); <span style="color: rgb(218, 146, 74);">// 解析后的方法</span></p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">const</span> <span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">appendix</span>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">call_info</span>.<span style="color: rgb(184, 191, 198);">resolved_appendix</span>(); <span style="color: rgb(218, 146, 74);">// 解析后的appendix对象</span></p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">const</span> <span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">method_type</span>&nbsp;<span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">call_info</span>.<span style="color: rgb(184, 191, 198);">resolved_method_type</span>(); <span style="color: rgb(218, 146, 74);">// 解析后的方法类型</span></p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">const</span> <span style="color: rgb(28, 198, 133);">bool</span> <span style="color: rgb(184, 191, 198);">has_appendix</span>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">appendix</span>.<span style="color: rgb(184, 191, 198);">not_null</span>();</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">const</span> <span style="color: rgb(28, 198, 133);">bool</span> <span style="color: rgb(184, 191, 198);">has_method_type</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">method_type</span>.<span style="color: rgb(184, 191, 198);">not_null</span>();</p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">objArrayHandle</span> <span style="color: rgb(184, 191, 198);">resolved_references</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">cpool-&gt;resolved_references</span>(); <span style="color: rgb(218, 146, 74);">// 保存常量池中已经解析的对象引用，也即实际对象的地址</span></p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 将appendix存储到resolved_references中</span></p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">has_appendix</span>) {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">const</span> <span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">appendix_index</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">f2_as_index</span>() <span style="color: rgb(184, 191, 198);">+</span> <span style="color: rgb(184, 191, 198);">_indy_resolved_references_appendix_offset</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">resolved_references-&gt;obj_at_put</span>(<span style="color: rgb(184, 191, 198);">appendix_index</span>, <span style="color: rgb(184, 191, 198);">appendix</span>());</p>
<p>}</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 将method_type存储到resolved_references中</span></p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">has_method_type</span>) {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">const</span> <span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">method_type_index</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">f2_as_index</span>() <span style="color: rgb(184, 191, 198);">+</span> <span style="color: rgb(184, 191, 198);">_indy_resolved_references_method_type_offset</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">resolved_references-&gt;obj_at_put</span>(<span style="color: rgb(184, 191, 198);">method_type_index</span>, <span style="color: rgb(184, 191, 198);">method_type</span>());</p>
<p>}</p>
<p>}</p>
<p>我们继续跟进 LinkResolver::resolve_invoke 方法，需要注意的是，该方法的将会将CallInfo的变量进行设置。看如下分析。</p>
<p><span style="color: rgb(28, 198, 133);">void</span> <span style="color: rgb(141, 141, 240);">LinkResolver::resolve_invoke</span>(<span style="color: rgb(184, 191, 198);">CallInfo&amp;</span> <span style="color: rgb(184, 191, 198);">result</span>, <span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">recv</span>, <span style="color: rgb(184, 191, 198);">constantPoolHandle</span> <span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">Bytecodes::Code</span> <span style="color: rgb(184, 191, 198);">byte</span>, <span style="color: rgb(184, 191, 198);">TRAPS</span>) {</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">switch</span> (<span style="color: rgb(184, 191, 198);">byte</span>) {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">case</span> <span style="color: rgb(184, 191, 198);">Bytecodes::_invokestatic</span>&nbsp;: <span style="color: rgb(184, 191, 198);">resolve_invokestatic</span>&nbsp;(<span style="color: rgb(184, 191, 198);">result</span>,&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>); <span style="color: rgb(200, 143, 208);">break</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">case</span> <span style="color: rgb(184, 191, 198);">Bytecodes::_invokespecial</span> : <span style="color: rgb(184, 191, 198);">resolve_invokespecial</span> (<span style="color: rgb(184, 191, 198);">result</span>,&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>); <span style="color: rgb(200, 143, 208);">break</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">case</span> <span style="color: rgb(184, 191, 198);">Bytecodes::_invokevirtual</span> : <span style="color: rgb(184, 191, 198);">resolve_invokevirtual</span> (<span style="color: rgb(184, 191, 198);">result</span>, <span style="color: rgb(184, 191, 198);">recv</span>, <span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>); <span style="color: rgb(200, 143, 208);">break</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">case</span> <span style="color: rgb(184, 191, 198);">Bytecodes::_invokehandle</span>&nbsp;: <span style="color: rgb(184, 191, 198);">resolve_invokehandle</span>&nbsp;(<span style="color: rgb(184, 191, 198);">result</span>,&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>); <span style="color: rgb(200, 143, 208);">break</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">case</span> <span style="color: rgb(184, 191, 198);">Bytecodes::_invokedynamic</span> : <span style="color: rgb(184, 191, 198);">resolve_invokedynamic</span> (<span style="color: rgb(184, 191, 198);">result</span>,&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>); <span style="color: rgb(200, 143, 208);">break</span>; <span style="color: rgb(218, 146, 74);">// 看这里即可</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">case</span> <span style="color: rgb(184, 191, 198);">Bytecodes::_invokeinterface</span>: <span style="color: rgb(184, 191, 198);">resolve_invokeinterface</span>(<span style="color: rgb(184, 191, 198);">result</span>, <span style="color: rgb(184, 191, 198);">recv</span>, <span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>); <span style="color: rgb(200, 143, 208);">break</span>;</p>
<p>}</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">return</span>;</p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(218, 146, 74);">// 完成对invokedynamic的解析</span></p>
<p><span style="color: rgb(28, 198, 133);">void</span> <span style="color: rgb(141, 141, 240);">LinkResolver::resolve_invokedynamic</span>(<span style="color: rgb(184, 191, 198);">CallInfo&amp;</span> <span style="color: rgb(184, 191, 198);">result</span>, <span style="color: rgb(184, 191, 198);">constantPoolHandle</span> <span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">TRAPS</span>) {</p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span> <span style="color: rgb(184, 191, 198);">method_name</span>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">pool-&gt;name_ref_at</span>(<span style="color: rgb(184, 191, 198);">index</span>); <span style="color: rgb(218, 146, 74);">// 获取到方法名</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span> <span style="color: rgb(184, 191, 198);">method_signature</span>&nbsp;<span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">pool-&gt;signature_ref_at</span>(<span style="color: rgb(184, 191, 198);">index</span>); <span style="color: rgb(218, 146, 74);">// 获取到方法签名</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">KlassHandle</span> <span style="color: rgb(184, 191, 198);">current_klass</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">KlassHandle</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">pool-&gt;pool_holder</span>()); <span style="color: rgb(218, 146, 74);">// 获取当前常量池表示的类对象这里为Demo.class的对象</span></p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 解析bootstrap方法</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">bootstrap_specifier</span>;</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">ConstantPoolCacheEntry*</span> <span style="color: rgb(184, 191, 198);">cpce</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">pool-&gt;invokedynamic_cp_cache_entry_at</span>(<span style="color: rgb(184, 191, 198);">index</span>);</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">cpce-&gt;is_f1_null</span>()) { <span style="color: rgb(218, 146, 74);">// 开始解析bsm（BootStrapMethod）</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">pool_index</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">cpce-&gt;constant_pool_index</span>();</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">oop</span> <span style="color: rgb(184, 191, 198);">bsm_info</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">pool-&gt;resolve_bootstrap_specifier_at</span>(<span style="color: rgb(184, 191, 198);">pool_index</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">bootstrap_specifier</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">Handle</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">bsm_info</span>); <span style="color: rgb(218, 146, 74);">// 获取BootStrapMethod的描述对象</span></p>
<p>}</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">!cpce-&gt;is_f1_null</span>()) { <span style="color: rgb(218, 146, 74);">// 之前已经完成解析，那么直接将解析后的结果放入CallInfo即可</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">methodHandle</span> <span style="color: rgb(184, 191, 198);">method</span>(&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">cpce-&gt;f1_as_method</span>());</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">appendix</span>(&nbsp;<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">cpce-&gt;appendix_if_resolved</span>(<span style="color: rgb(184, 191, 198);">pool</span>));</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">method_type</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">cpce-&gt;method_type_if_resolved</span>(<span style="color: rgb(184, 191, 198);">pool</span>));</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">result</span>.<span style="color: rgb(184, 191, 198);">set_handle</span>(<span style="color: rgb(184, 191, 198);">method</span>, <span style="color: rgb(184, 191, 198);">appendix</span>, <span style="color: rgb(184, 191, 198);">method_type</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span>;</p>
<p>}</p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 完成实际解析</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">resolve_dynamic_call</span>(<span style="color: rgb(184, 191, 198);">result</span>, <span style="color: rgb(184, 191, 198);">bootstrap_specifier</span>, <span style="color: rgb(184, 191, 198);">method_name</span>, <span style="color: rgb(184, 191, 198);">method_signature</span>, <span style="color: rgb(184, 191, 198);">current_klass</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>);</p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(218, 146, 74);">// 解析bsm</span></p>
<p><span style="color: rgb(184, 191, 198);">oop</span> <span style="color: rgb(141, 141, 240);">ConstantPool::resolve_bootstrap_specifier_at_impl</span>(<span style="color: rgb(184, 191, 198);">constantPoolHandle</span> <span style="color: rgb(184, 191, 198);">this_oop</span>, <span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">TRAPS</span>) {</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">bsm</span>;</p>
<p>&nbsp;<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">argc</span>;</p>
<p>{</p>
<p>&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">bsm_index</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">this_oop-&gt;invoke_dynamic_bootstrap_method_ref_index_at</span>(<span style="color: rgb(184, 191, 198);">index</span>); <span style="color: rgb(218, 146, 74);">// 获取InvokeDynamic指向bsm的下标</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">oop</span> <span style="color: rgb(184, 191, 198);">bsm_oop</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">this_oop-&gt;resolve_possibly_cached_constant_at</span>(<span style="color: rgb(184, 191, 198);">bsm_index</span>, <span style="color: rgb(184, 191, 198);">CHECK_NULL</span>); <span style="color: rgb(218, 146, 74);">// 解析并获取到MethodHandle对象（读者先记住一个前提：oop 就是Java中的对象，这里是指向该对象的指针）</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">!java_lang_invoke_MethodHandle::is_instance</span>(<span style="color: rgb(184, 191, 198);">bsm_oop</span>)) {&nbsp;<span style="color: rgb(218, 146, 74);">// bsm描述对象必须为MethodHandle类的实例</span></p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">THROW_MSG_NULL</span>(<span style="color: rgb(184, 191, 198);">vmSymbols::java_lang_LinkageError</span>(), <span style="color: rgb(210, 107, 107);">"BSM not an MethodHandle"</span>);</p>
<p>&nbsp;}</p>
<p>​</p>
<p>&nbsp;&nbsp;<span style="color: rgb(218, 146, 74);">// 如果有额外的静态参数，那么提取额外的参数，了解一下即可，重点在于MethodHandle对象如何获取</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">argc</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">this_oop-&gt;invoke_dynamic_argument_count_at</span>(<span style="color: rgb(184, 191, 198);">index</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">argc</span> <span style="color: rgb(184, 191, 198);">==</span> <span style="color: rgb(100, 171, 143);">0</span>)&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">bsm_oop</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">bsm</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">Handle</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">bsm_oop</span>);</p>
<p>}</p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">objArrayHandle</span> <span style="color: rgb(184, 191, 198);">info</span>;</p>
<p>{</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">objArrayOop</span> <span style="color: rgb(184, 191, 198);">info_oop</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">oopFactory::new_objArray</span>(<span style="color: rgb(184, 191, 198);">SystemDictionary::Object_klass</span>(), <span style="color: rgb(100, 171, 143);">1</span><span style="color: rgb(184, 191, 198);">+argc</span>, <span style="color: rgb(184, 191, 198);">CHECK_NULL</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">info</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">objArrayHandle</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">info_oop</span>);</p>
<p>}</p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">info-&gt;obj_at_put</span>(<span style="color: rgb(100, 171, 143);">0</span>, <span style="color: rgb(184, 191, 198);">bsm</span>());</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">for</span> (<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">i</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(100, 171, 143);">0</span>; <span style="color: rgb(184, 191, 198);">i</span> <span style="color: rgb(184, 191, 198);">&lt;</span> <span style="color: rgb(184, 191, 198);">argc</span>; <span style="color: rgb(184, 191, 198);">i++</span>) {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">arg_index</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">this_oop-&gt;invoke_dynamic_argument_index_at</span>(<span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">i</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">oop</span> <span style="color: rgb(184, 191, 198);">arg_oop</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">this_oop-&gt;resolve_possibly_cached_constant_at</span>(<span style="color: rgb(184, 191, 198);">arg_index</span>, <span style="color: rgb(184, 191, 198);">CHECK_NULL</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">info-&gt;obj_at_put</span>(<span style="color: rgb(100, 171, 143);">1</span><span style="color: rgb(184, 191, 198);">+i</span>, <span style="color: rgb(184, 191, 198);">arg_oop</span>);</p>
<p>}</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">info</span>();</p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(218, 146, 74);">// 解析MethodHandle对象</span></p>
<p><span style="color: rgb(184, 191, 198);">oop</span> <span style="color: rgb(141, 141, 240);">resolve_possibly_cached_constant_at</span>(<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">pool_index</span>, <span style="color: rgb(184, 191, 198);">TRAPS</span>) {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">constantPoolHandle</span> <span style="color: rgb(184, 191, 198);">h_this</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(200, 143, 208);">this</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">resolve_constant_at_impl</span>(<span style="color: rgb(184, 191, 198);">h_this</span>, <span style="color: rgb(184, 191, 198);">pool_index</span>, <span style="color: rgb(184, 191, 198);">_possible_index_sentinel</span>, <span style="color: rgb(184, 191, 198);">THREAD</span>);</p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(218, 146, 74);">// 完成实际解析</span></p>
<p><span style="color: rgb(184, 191, 198);">oop</span> <span style="color: rgb(141, 141, 240);">ConstantPool::resolve_constant_at_impl</span>(<span style="color: rgb(184, 191, 198);">constantPoolHandle</span> <span style="color: rgb(184, 191, 198);">this_oop</span>, <span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">cache_index</span>, <span style="color: rgb(184, 191, 198);">TRAPS</span>) {</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">oop</span> <span style="color: rgb(184, 191, 198);">result_oop</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">NULL</span>;</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">throw_exception</span>;</p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">tag_value</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">this_oop-&gt;tag_at</span>(<span style="color: rgb(184, 191, 198);">index</span>).<span style="color: rgb(184, 191, 198);">value</span>(); <span style="color: rgb(218, 146, 74);">// 获取该索引下标指向的常量池下标表示的常量池类型（还记得一开始的 BootstrapMethods: 0: #20 ，#20 = MethodHandle&nbsp;&nbsp;&nbsp;#6:#33 ）所以我们这里只需要看MethodHandle即可</span></p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">switch</span> (<span style="color: rgb(184, 191, 198);">tag_value</span>) {</p>
<p>...</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">case</span> <span style="color: rgb(184, 191, 198);">JVM_CONSTANT_MethodHandle</span>:</p>
<p>&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">ref_kind</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">this_oop-&gt;method_handle_ref_kind_at</span>(<span style="color: rgb(184, 191, 198);">index</span>); <span style="color: rgb(218, 146, 74);">// 获取到MethodHandle 的引用类型（这里为invoke_static）</span></p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">callee_index</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">this_oop-&gt;method_handle_klass_index_at</span>(<span style="color: rgb(184, 191, 198);">index</span>); <span style="color: rgb(218, 146, 74);">// 获取到指向Methodref的索引</span></p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span>&nbsp;<span style="color: rgb(184, 191, 198);">name</span> <span style="color: rgb(184, 191, 198);">=</span>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">this_oop-&gt;method_handle_name_ref_at</span>(<span style="color: rgb(184, 191, 198);">index</span>);&nbsp;<span style="color: rgb(218, 146, 74);">// 获取到类名（这里为：java/lang/invoke/LambdaMetafactory.metafactory，之前字节码中有描述哦）</span></p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span>&nbsp;<span style="color: rgb(184, 191, 198);">signature</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">this_oop-&gt;method_handle_signature_ref_at</span>(<span style="color: rgb(184, 191, 198);">index</span>); <span style="color: rgb(218, 146, 74);">// 获取到方法签名</span></p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">KlassHandle</span> <span style="color: rgb(184, 191, 198);">callee</span>; <span style="color: rgb(218, 146, 74);">// 首先获取到LambdaMetafactory的类对象</span></p>
<p>&nbsp;&nbsp;{ <span style="color: rgb(184, 191, 198);">Klass*</span> <span style="color: rgb(184, 191, 198);">k</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">klass_at_impl</span>(<span style="color: rgb(184, 191, 198);">this_oop</span>, <span style="color: rgb(184, 191, 198);">callee_index</span>, <span style="color: rgb(184, 191, 198);">CHECK_NULL</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">callee</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">KlassHandle</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">k</span>);</p>
<p>&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">KlassHandle</span> <span style="color: rgb(184, 191, 198);">klass</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">this_oop-&gt;pool_holder</span>());</p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">value</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">SystemDictionary::link_method_handle_constant</span>(<span style="color: rgb(184, 191, 198);">klass</span>, <span style="color: rgb(184, 191, 198);">ref_kind</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">callee</span>, <span style="color: rgb(184, 191, 198);">name</span>, <span style="color: rgb(184, 191, 198);">signature</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">THREAD</span>); <span style="color: rgb(218, 146, 74);">// 完成方法的链接</span></p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">result_oop</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">value</span>(); <span style="color: rgb(218, 146, 74);">// 返回链接对象</span></p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">break</span>;</p>
<p>&nbsp;}</p>
<p>...</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">default</span>:</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">DEBUG_ONLY</span>( <span style="color: rgb(184, 191, 198);">tty-&gt;print_cr</span>(<span style="color: rgb(210, 107, 107);">"*** %p: tag at CP[%d/%d] = %d"</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">this_oop</span>(), <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">cache_index</span>, <span style="color: rgb(184, 191, 198);">tag_value</span>) );</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">assert</span>(<span style="color: rgb(132, 182, 203);">false</span>, <span style="color: rgb(210, 107, 107);">"unexpected constant tag"</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">break</span>;</p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(218, 146, 74);">// 完成MethodHandle的解析</span></p>
<p><span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(141, 141, 240);">SystemDictionary::link_method_handle_constant</span>(<span style="color: rgb(184, 191, 198);">KlassHandle</span> <span style="color: rgb(184, 191, 198);">caller</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">ref_kind</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">KlassHandle</span> <span style="color: rgb(184, 191, 198);">callee</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span> <span style="color: rgb(184, 191, 198);">name_sym</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span> <span style="color: rgb(184, 191, 198);">signature</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">TRAPS</span>) {</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">empty</span>;</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">name</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">java_lang_String::create_from_symbol</span>(<span style="color: rgb(184, 191, 198);">name_sym</span>, <span style="color: rgb(184, 191, 198);">CHECK_</span>(<span style="color: rgb(184, 191, 198);">empty</span>));</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">type</span>;</p>
<p>...</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 调用Java 层面的 java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant(Class caller, int refKind, Class callee, String name, Object type) 然后获取到 MethodHandle 对象</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">JavaCallArguments</span> <span style="color: rgb(184, 191, 198);">args</span>; <span style="color: rgb(218, 146, 74);">// 构建参数列表</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_oop</span>(<span style="color: rgb(184, 191, 198);">caller-&gt;java_mirror</span>());&nbsp;</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_int</span>(<span style="color: rgb(184, 191, 198);">ref_kind</span>);</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_oop</span>(<span style="color: rgb(184, 191, 198);">callee-&gt;java_mirror</span>());</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_oop</span>(<span style="color: rgb(184, 191, 198);">name</span>());</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_oop</span>(<span style="color: rgb(184, 191, 198);">type</span>());</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">JavaValue</span> <span style="color: rgb(184, 191, 198);">result</span>(<span style="color: rgb(184, 191, 198);">T_OBJECT</span>);</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">JavaCalls::call_static</span>(<span style="color: rgb(184, 191, 198);">&amp;result</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">SystemDictionary::MethodHandleNatives_klass</span>(),</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">vmSymbols::linkMethodHandleConstant_name</span>(),</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">vmSymbols::linkMethodHandleConstant_signature</span>(),</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">&amp;args</span>, <span style="color: rgb(184, 191, 198);">CHECK_</span>(<span style="color: rgb(184, 191, 198);">empty</span>)); <span style="color: rgb(218, 146, 74);">// 完成实际调用</span></p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">Handle</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, (<span style="color: rgb(184, 191, 198);">oop</span>) <span style="color: rgb(184, 191, 198);">result</span>.<span style="color: rgb(184, 191, 198);">get_jobject</span>());&nbsp;<span style="color: rgb(218, 146, 74);">// 包装调用结果返回的MethodHandle对象</span></p>
<p>}</p>
<p>what?回到了Java 层面？是的，以上调用链很长，但是读者必须要记住的是我们在干啥：解析BSM获取到MethodHandle对象，来吧继续跟进Java的java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant方法实现过程，这里时刻记得我们的参数是什么？</p>
<p><span style="color: rgb(200, 143, 208);">class</span> <span style="color: rgb(141, 141, 240);">MethodHandleNatives</span> {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(218, 146, 74);">// callerClass: Demo，refKind：invoke_static， defc：java.lang.invoke.LambdaMetafactory ，name:metafactory , type: (Lookup,String,MethodType,MethodType,MethodHandle,MethodType) CallSite</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">static</span> <span style="color: rgb(184, 191, 198);">MethodHandle</span> <span style="color: rgb(184, 191, 198);">linkMethodHandleConstant</span>(<span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span> <span style="color: rgb(184, 191, 198);">callerClass</span>, <span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">refKind</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span> <span style="color: rgb(184, 191, 198);">defc</span>, <span style="color: rgb(28, 198, 133);">String</span> <span style="color: rgb(184, 191, 198);">name</span>, <span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">type</span>) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">try</span> {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Lookup</span> <span style="color: rgb(184, 191, 198);">lookup</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">IMPL_LOOKUP</span>.<span style="color: rgb(184, 191, 198);">in</span>(<span style="color: rgb(184, 191, 198);">callerClass</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">lookup</span>.<span style="color: rgb(184, 191, 198);">linkMethodHandleConstant</span>((<span style="color: rgb(28, 198, 133);">byte</span>) <span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">defc</span>, <span style="color: rgb(184, 191, 198);">name</span>, <span style="color: rgb(184, 191, 198);">type</span>);</p>
<p>&nbsp;&nbsp;&nbsp;} <span style="color: rgb(200, 143, 208);">catch</span> (<span style="color: rgb(184, 191, 198);">IllegalAccessException</span> <span style="color: rgb(184, 191, 198);">ex</span>) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</p>
<p>&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;}</p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(200, 143, 208);">public</span> <span style="color: rgb(200, 143, 208);">class</span> <span style="color: rgb(141, 141, 240);">MethodHandles</span> {</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(218, 146, 74);">// 链接MethodHandle</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MethodHandle</span> <span style="color: rgb(184, 191, 198);">linkMethodHandleConstant</span>(<span style="color: rgb(28, 198, 133);">byte</span> <span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span> <span style="color: rgb(184, 191, 198);">defc</span>, <span style="color: rgb(28, 198, 133);">String</span> <span style="color: rgb(184, 191, 198);">name</span>, <span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">type</span>) <span style="color: rgb(200, 143, 208);">throws</span> <span style="color: rgb(184, 191, 198);">ReflectiveOperationException</span> {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MemberName</span> <span style="color: rgb(184, 191, 198);">member</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(200, 143, 208);">new</span> <span style="color: rgb(184, 191, 198);">MemberName</span>(<span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">defc</span>, <span style="color: rgb(184, 191, 198);">name</span>, <span style="color: rgb(184, 191, 198);">type</span>); <span style="color: rgb(218, 146, 74);">// 创建MN 保存方法的元数据</span></p>
<p>&nbsp;&nbsp;&nbsp;...</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MemberName</span> <span style="color: rgb(184, 191, 198);">resolved</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">resolveOrFail</span>(<span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">member</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">mh</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">getDirectMethodForConstant</span>(<span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">defc</span>, <span style="color: rgb(184, 191, 198);">resolved</span>); <span style="color: rgb(218, 146, 74);">// 获取MethodHandle对象</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">mh</span> <span style="color: rgb(200, 143, 208);">instanceof</span> <span style="color: rgb(184, 191, 198);">DirectMethodHandle</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">&amp;&amp;</span> <span style="color: rgb(184, 191, 198);">canBeCached</span>(<span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">defc</span>, <span style="color: rgb(184, 191, 198);">resolved</span>)) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MemberName</span> <span style="color: rgb(184, 191, 198);">key</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">mh</span>.<span style="color: rgb(184, 191, 198);">internalMemberName</span>();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">key</span> <span style="color: rgb(184, 191, 198);">!=</span> <span style="color: rgb(132, 182, 203);">null</span>) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">key</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">key</span>.<span style="color: rgb(184, 191, 198);">asNormalOriginal</span>();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">member</span>.<span style="color: rgb(184, 191, 198);">equals</span>(<span style="color: rgb(184, 191, 198);">key</span>)) {&nbsp;<span style="color: rgb(218, 146, 74);">// better safe than sorry</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">LOOKASIDE_TABLE</span>.<span style="color: rgb(184, 191, 198);">put</span>(<span style="color: rgb(184, 191, 198);">key</span>, (<span style="color: rgb(184, 191, 198);">DirectMethodHandle</span>) <span style="color: rgb(184, 191, 198);">mh</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">mh</span>;</p>
<p>&nbsp;}</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">private</span> <span style="color: rgb(184, 191, 198);">MethodHandle</span> <span style="color: rgb(184, 191, 198);">getDirectMethodForConstant</span>(<span style="color: rgb(28, 198, 133);">byte</span> <span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span> <span style="color: rgb(184, 191, 198);">defc</span>, <span style="color: rgb(184, 191, 198);">MemberName</span> <span style="color: rgb(184, 191, 198);">member</span>) <span style="color: rgb(200, 143, 208);">throws</span> <span style="color: rgb(184, 191, 198);">ReflectiveOperationException</span> {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">getDirectMethodNoSecurityManager</span>(<span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">defc</span>, <span style="color: rgb(184, 191, 198);">member</span>, <span style="color: rgb(184, 191, 198);">lookupClass</span>);</p>
<p>&nbsp;}</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">private</span> <span style="color: rgb(184, 191, 198);">MethodHandle</span> <span style="color: rgb(184, 191, 198);">getDirectMethodNoSecurityManager</span>(<span style="color: rgb(28, 198, 133);">byte</span> <span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span> <span style="color: rgb(184, 191, 198);">refc</span>, <span style="color: rgb(184, 191, 198);">MemberName</span> <span style="color: rgb(184, 191, 198);">method</span>, <span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span> <span style="color: rgb(184, 191, 198);">callerClass</span>) <span style="color: rgb(200, 143, 208);">throws</span> <span style="color: rgb(184, 191, 198);">IllegalAccessException</span> {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">final</span> <span style="color: rgb(28, 198, 133);">boolean</span> <span style="color: rgb(184, 191, 198);">doRestrict</span>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(132, 182, 203);">true</span>;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">final</span> <span style="color: rgb(28, 198, 133);">boolean</span> <span style="color: rgb(184, 191, 198);">checkSecurity</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(132, 182, 203);">false</span>;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">getDirectMethodCommon</span>(<span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">refc</span>, <span style="color: rgb(184, 191, 198);">method</span>, <span style="color: rgb(184, 191, 198);">checkSecurity</span>, <span style="color: rgb(184, 191, 198);">doRestrict</span>, <span style="color: rgb(184, 191, 198);">callerClass</span>);</p>
<p>&nbsp;}</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(218, 146, 74);">// 完成实际MethodHandle生成</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">private</span> <span style="color: rgb(184, 191, 198);">MethodHandle</span> <span style="color: rgb(184, 191, 198);">getDirectMethodCommon</span>(<span style="color: rgb(28, 198, 133);">byte</span> <span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span> <span style="color: rgb(184, 191, 198);">refc</span>, <span style="color: rgb(184, 191, 198);">MemberName</span> <span style="color: rgb(184, 191, 198);">method</span>,<span style="color: rgb(28, 198, 133);">boolean</span> <span style="color: rgb(184, 191, 198);">checkSecurity</span>,<span style="color: rgb(28, 198, 133);">boolean</span> <span style="color: rgb(184, 191, 198);">doRestrict</span>, <span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span> <span style="color: rgb(184, 191, 198);">callerClass</span>) <span style="color: rgb(200, 143, 208);">throws</span> <span style="color: rgb(184, 191, 198);">IllegalAccessException</span> {</p>
<p>&nbsp;...</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">DirectMethodHandle</span> <span style="color: rgb(184, 191, 198);">dmh</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">DirectMethodHandle</span>.<span style="color: rgb(184, 191, 198);">make</span>(<span style="color: rgb(184, 191, 198);">refKind</span>, <span style="color: rgb(184, 191, 198);">refc</span>, <span style="color: rgb(184, 191, 198);">method</span>); <span style="color: rgb(218, 146, 74);">// 生成直接方法调用中间类，这里的DirectMethodHandle 将会指向生成中间类的信息，该中间类将会直接调用（java.lang.invoke.LambdaMetafactory）</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MethodHandle</span> <span style="color: rgb(184, 191, 198);">mh</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">dmh</span>;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">doRestrict</span> <span style="color: rgb(184, 191, 198);">&amp;&amp;</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color: rgb(184, 191, 198);">refKind</span> <span style="color: rgb(184, 191, 198);">==</span> <span style="color: rgb(184, 191, 198);">REF_invokeSpecial</span> <span style="color: rgb(184, 191, 198);">||</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color: rgb(184, 191, 198);">MethodHandleNatives</span>.<span style="color: rgb(184, 191, 198);">refKindHasReceiver</span>(<span style="color: rgb(184, 191, 198);">refKind</span>) <span style="color: rgb(184, 191, 198);">&amp;&amp;</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">restrictProtectedReceiver</span>(<span style="color: rgb(184, 191, 198);">method</span>)))) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">mh</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">restrictReceiver</span>(<span style="color: rgb(184, 191, 198);">method</span>, <span style="color: rgb(184, 191, 198);">dmh</span>, <span style="color: rgb(184, 191, 198);">lookupClass</span>());</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">mh</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">maybeBindCaller</span>(<span style="color: rgb(184, 191, 198);">method</span>, <span style="color: rgb(184, 191, 198);">mh</span>, <span style="color: rgb(184, 191, 198);">callerClass</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">mh</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">mh</span>.<span style="color: rgb(184, 191, 198);">setVarargs</span>(<span style="color: rgb(184, 191, 198);">method</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">mh</span>;</p>
<p>&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>我们在上面看到DirectMethodHandle的对象的创建，将会得到一个指向由JVM生成的中间类的方法，这个过程将在 DirectMethodHandle.make(refKind, refc, method) 方法中执行，由于其中真的很复杂而且太多太多了，笔者有心无力，写完估计一个世纪过去了，里面的前置知识也非常多，所以笔者这里将生成的类打印反编译。给大家看看它长啥样。如下所示，对的，我们生成的DirectMethodHandle指向的就是invokeStatic_005_L6_L，而其中将会调用MethodHandle.linkToStatic，该方法的实现为JNI方法，底层实现也非常简单，直接调用其中的指向的方法：java/lang/invoke/LambdaMetafactory.metafactory。</p>
<p><span style="color: rgb(200, 143, 208);">final</span> <span style="color: rgb(200, 143, 208);">class</span> <span style="color: rgb(141, 141, 240);">LambdaForm$DMH006</span> {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(183, 179, 179);">@Hidden</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(183, 179, 179);">@Compiled</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(183, 179, 179);">@ForceInline</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">static</span> <span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">invokeStatic_005_L6_L</span>(<span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">var0</span>, <span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">var1</span>, <span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">var2</span>, <span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">var3</span>, <span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">var4</span>, <span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">var5</span>, <span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">var6</span>) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">var7</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">DirectMethodHandle</span>.<span style="color: rgb(184, 191, 198);">internalMemberName</span>(<span style="color: rgb(184, 191, 198);">var0</span>);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">MethodHandle</span>.<span style="color: rgb(184, 191, 198);">linkToStatic</span>(<span style="color: rgb(184, 191, 198);">var1</span>, <span style="color: rgb(184, 191, 198);">var2</span>, <span style="color: rgb(184, 191, 198);">var3</span>, <span style="color: rgb(184, 191, 198);">var4</span>, <span style="color: rgb(184, 191, 198);">var5</span>, <span style="color: rgb(184, 191, 198);">var6</span>, (<span style="color: rgb(184, 191, 198);">MemberName</span>)<span style="color: rgb(184, 191, 198);">var7</span>);</p>
<p>&nbsp;}</p>
<p>}</p>
<p>至此我们得到指向LambdaMetafactory.metafactory方法的MethodHandle 对象了，我们需要回到JVM的层面。</p>
<p><span style="color: rgb(218, 146, 74);">// 还记得这个方法吧</span></p>
<p><span style="color: rgb(28, 198, 133);">void</span> <span style="color: rgb(141, 141, 240);">LinkResolver::resolve_invokedynamic</span>(<span style="color: rgb(184, 191, 198);">CallInfo&amp;</span> <span style="color: rgb(184, 191, 198);">result</span>, <span style="color: rgb(184, 191, 198);">constantPoolHandle</span> <span style="color: rgb(184, 191, 198);">pool</span>, <span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">index</span>, <span style="color: rgb(184, 191, 198);">TRAPS</span>) {</p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span> <span style="color: rgb(184, 191, 198);">method_name</span>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">pool-&gt;name_ref_at</span>(<span style="color: rgb(184, 191, 198);">index</span>); <span style="color: rgb(218, 146, 74);">// 获取到方法名</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span> <span style="color: rgb(184, 191, 198);">method_signature</span>&nbsp;<span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">pool-&gt;signature_ref_at</span>(<span style="color: rgb(184, 191, 198);">index</span>); <span style="color: rgb(218, 146, 74);">// 获取到方法签名</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">KlassHandle</span> <span style="color: rgb(184, 191, 198);">current_klass</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">KlassHandle</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">pool-&gt;pool_holder</span>()); <span style="color: rgb(218, 146, 74);">// 获取当前常量池表示的类对象这里为Demo.class的对象</span></p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 解析bootstrap方法</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">bootstrap_specifier</span>; <span style="color: rgb(218, 146, 74);">// 现在我们已经有了bootstrap_specifier方法的MethodHandle对象了</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">ConstantPoolCacheEntry*</span> <span style="color: rgb(184, 191, 198);">cpce</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">pool-&gt;invokedynamic_cp_cache_entry_at</span>(<span style="color: rgb(184, 191, 198);">index</span>);</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">cpce-&gt;is_f1_null</span>()) { <span style="color: rgb(218, 146, 74);">// 开始解析bsm（BootStrapMethod）</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">int</span> <span style="color: rgb(184, 191, 198);">pool_index</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">cpce-&gt;constant_pool_index</span>();</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">oop</span> <span style="color: rgb(184, 191, 198);">bsm_info</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">pool-&gt;resolve_bootstrap_specifier_at</span>(<span style="color: rgb(184, 191, 198);">pool_index</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">bootstrap_specifier</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">Handle</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">bsm_info</span>); <span style="color: rgb(218, 146, 74);">// 获取BootStrapMethod的描述对象</span></p>
<p>}</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">!cpce-&gt;is_f1_null</span>()) { <span style="color: rgb(218, 146, 74);">// 之前已经完成解析，那么直接将解析后的结果放入CallInfo即可</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">methodHandle</span> <span style="color: rgb(184, 191, 198);">method</span>(&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">cpce-&gt;f1_as_method</span>());</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">appendix</span>(&nbsp;<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">cpce-&gt;appendix_if_resolved</span>(<span style="color: rgb(184, 191, 198);">pool</span>));</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">method_type</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">cpce-&gt;method_type_if_resolved</span>(<span style="color: rgb(184, 191, 198);">pool</span>));</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">result</span>.<span style="color: rgb(184, 191, 198);">set_handle</span>(<span style="color: rgb(184, 191, 198);">method</span>, <span style="color: rgb(184, 191, 198);">appendix</span>, <span style="color: rgb(184, 191, 198);">method_type</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span>;</p>
<p>}</p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 完成实际解析（现在我们继续研究它）</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">resolve_dynamic_call</span>(<span style="color: rgb(184, 191, 198);">result</span>, <span style="color: rgb(184, 191, 198);">bootstrap_specifier</span>, <span style="color: rgb(184, 191, 198);">method_name</span>, <span style="color: rgb(184, 191, 198);">method_signature</span>, <span style="color: rgb(184, 191, 198);">current_klass</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>);</p>
<p>}</p>
<p>我们继续跟进resolve_dynamic_call方法。</p>
<p><span style="color: rgb(28, 198, 133);">void</span> <span style="color: rgb(141, 141, 240);">LinkResolver::resolve_dynamic_call</span>(<span style="color: rgb(184, 191, 198);">CallInfo&amp;</span> <span style="color: rgb(184, 191, 198);">result</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">bootstrap_specifier</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span> <span style="color: rgb(184, 191, 198);">method_name</span>, <span style="color: rgb(184, 191, 198);">Symbol*</span> <span style="color: rgb(184, 191, 198);">method_signature</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">KlassHandle</span> <span style="color: rgb(184, 191, 198);">current_klass</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">TRAPS</span>) {</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">resolved_appendix</span>;</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">resolved_method_type</span>;</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">methodHandle</span> <span style="color: rgb(184, 191, 198);">resolved_method</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">SystemDictionary::find_dynamic_call_site_invoker</span>(<span style="color: rgb(184, 191, 198);">current_klass</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">bootstrap_specifier</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">method_name</span>, <span style="color: rgb(184, 191, 198);">method_signature</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">&amp;resolved_appendix</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">&amp;resolved_method_type</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">THREAD</span>); <span style="color: rgb(218, 146, 74);">// 解析方法</span></p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 将解析后的信息放入CallInfo</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">result</span>.<span style="color: rgb(184, 191, 198);">set_handle</span>(<span style="color: rgb(184, 191, 198);">resolved_method</span>, <span style="color: rgb(184, 191, 198);">resolved_appendix</span>, <span style="color: rgb(184, 191, 198);">resolved_method_type</span>, <span style="color: rgb(184, 191, 198);">CHECK</span>);</p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(218, 146, 74);">// 获取到调用callsite的调用方法</span></p>
<p><span style="color: rgb(184, 191, 198);">methodHandle</span> <span style="color: rgb(141, 141, 240);">SystemDictionary::find_dynamic_call_site_invoker</span>(<span style="color: rgb(184, 191, 198);">KlassHandle</span> <span style="color: rgb(184, 191, 198);">caller</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">bootstrap_specifier</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span> <span style="color: rgb(184, 191, 198);">name</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Symbol*</span> <span style="color: rgb(184, 191, 198);">type</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">*appendix_result</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">*method_type_result</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">TRAPS</span>) {</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">methodHandle</span> <span style="color: rgb(184, 191, 198);">empty</span>;</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">bsm</span>, <span style="color: rgb(184, 191, 198);">info</span>;</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">java_lang_invoke_MethodHandle::is_instance</span>(<span style="color: rgb(184, 191, 198);">bootstrap_specifier</span>())) {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">bsm</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">bootstrap_specifier</span>; <span style="color: rgb(218, 146, 74);">// bootstrap_specifier为MethodHandle实例，那么将其设置为bsm(看着里即可)</span></p>
<p>} <span style="color: rgb(200, 143, 208);">else</span> {</p>
<p>&nbsp;...</p>
<p>}</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">method_name</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">java_lang_String::create_from_symbol</span>(<span style="color: rgb(184, 191, 198);">name</span>, <span style="color: rgb(184, 191, 198);">CHECK_</span>(<span style="color: rgb(184, 191, 198);">empty</span>)); <span style="color: rgb(218, 146, 74);">// 方法名</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">method_type</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">find_method_handle_type</span>(<span style="color: rgb(184, 191, 198);">type</span>, <span style="color: rgb(184, 191, 198);">caller</span>, <span style="color: rgb(184, 191, 198);">CHECK_</span>(<span style="color: rgb(184, 191, 198);">empty</span>)); <span style="color: rgb(218, 146, 74);">// 方法类型</span></p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">objArrayHandle</span> <span style="color: rgb(184, 191, 198);">appendix_box</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">oopFactory::new_objArray</span>(<span style="color: rgb(184, 191, 198);">SystemDictionary::Object_klass</span>(), <span style="color: rgb(100, 171, 143);">1</span>, <span style="color: rgb(184, 191, 198);">CHECK_</span>(<span style="color: rgb(184, 191, 198);">empty</span>));</p>
<p>​</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 调用Java层面的方法 java.lang.invoke.MethodHandleNatives::linkCallSite(caller, bsm, name, mtype, info, &amp;appendix)</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">JavaCallArguments</span> <span style="color: rgb(184, 191, 198);">args</span>; <span style="color: rgb(218, 146, 74);">// 构建参数列表</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_oop</span>(<span style="color: rgb(184, 191, 198);">caller-&gt;java_mirror</span>());</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_oop</span>(<span style="color: rgb(184, 191, 198);">bsm</span>()); <span style="color: rgb(218, 146, 74);">// 传入了MethodHandle</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_oop</span>(<span style="color: rgb(184, 191, 198);">method_name</span>());</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_oop</span>(<span style="color: rgb(184, 191, 198);">method_type</span>());</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_oop</span>(<span style="color: rgb(184, 191, 198);">info</span>());</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">args</span>.<span style="color: rgb(184, 191, 198);">push_oop</span>(<span style="color: rgb(184, 191, 198);">appendix_box</span>);</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">JavaValue</span> <span style="color: rgb(184, 191, 198);">result</span>(<span style="color: rgb(184, 191, 198);">T_OBJECT</span>); <span style="color: rgb(218, 146, 74);">// 保存结果</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">JavaCalls::call_static</span>(<span style="color: rgb(184, 191, 198);">&amp;result</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">SystemDictionary::MethodHandleNatives_klass</span>(),</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">vmSymbols::linkCallSite_name</span>(),</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">vmSymbols::linkCallSite_signature</span>(),</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">&amp;args</span>, <span style="color: rgb(184, 191, 198);">CHECK_</span>(<span style="color: rgb(184, 191, 198);">empty</span>)); <span style="color: rgb(218, 146, 74);">// 开始调用</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">mname</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, (<span style="color: rgb(184, 191, 198);">oop</span>) <span style="color: rgb(184, 191, 198);">result</span>.<span style="color: rgb(184, 191, 198);">get_jobject</span>());</p>
<p>(<span style="color: rgb(184, 191, 198);">*method_type_result</span>) <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">method_type</span>;</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">unpack_method_and_appendix</span>(<span style="color: rgb(184, 191, 198);">mname</span>, <span style="color: rgb(184, 191, 198);">caller</span>, <span style="color: rgb(184, 191, 198);">appendix_box</span>, <span style="color: rgb(184, 191, 198);">appendix_result</span>, <span style="color: rgb(184, 191, 198);">THREAD</span>);</p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(218, 146, 74);">// 调用完毕后将method和appendix解包</span></p>
<p><span style="color: rgb(200, 143, 208);">static</span> <span style="color: rgb(184, 191, 198);">methodHandle</span> <span style="color: rgb(141, 141, 240);">unpack_method_and_appendix</span>(<span style="color: rgb(184, 191, 198);">Handle</span> <span style="color: rgb(184, 191, 198);">mname</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">KlassHandle</span> <span style="color: rgb(184, 191, 198);">accessing_klass</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">objArrayHandle</span> <span style="color: rgb(184, 191, 198);">appendix_box</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Handle*</span> <span style="color: rgb(184, 191, 198);">appendix_result</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">TRAPS</span>) {</p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">methodHandle</span> <span style="color: rgb(184, 191, 198);">empty</span>;</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">mname</span>.<span style="color: rgb(184, 191, 198);">not_null</span>()) {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Metadata*</span> <span style="color: rgb(184, 191, 198);">vmtarget</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">java_lang_invoke_MemberName::vmtarget</span>(<span style="color: rgb(184, 191, 198);">mname</span>()); <span style="color: rgb(218, 146, 74);">// 获取到MemberName方法结构中描述的调用方法的元数据</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">vmtarget</span> <span style="color: rgb(184, 191, 198);">!=</span> <span style="color: rgb(184, 191, 198);">NULL</span> <span style="color: rgb(184, 191, 198);">&amp;&amp;</span> <span style="color: rgb(184, 191, 198);">vmtarget-&gt;is_method</span>()) {</p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Method*</span> <span style="color: rgb(184, 191, 198);">m</span> <span style="color: rgb(184, 191, 198);">=</span> (<span style="color: rgb(184, 191, 198);">Method*</span>)<span style="color: rgb(184, 191, 198);">vmtarget</span>; <span style="color: rgb(218, 146, 74);">// 转为实际调用方法的指针</span></p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">oop</span> <span style="color: rgb(184, 191, 198);">appendix</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">appendix_box-&gt;obj_at</span>(<span style="color: rgb(100, 171, 143);">0</span>); <span style="color: rgb(218, 146, 74);">// 获取调用方法时传递的Java对象，该对象前面我们看到在MethodHandleNatives::linkCallSite方法中设置</span></p>
<p>&nbsp;&nbsp;(<span style="color: rgb(184, 191, 198);">*appendix_result</span>) <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">Handle</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">appendix</span>); <span style="color: rgb(218, 146, 74);">// 将该对象包装为Handle指针，方便计算</span></p>
<p>&nbsp;&nbsp;...</p>
<p>&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">methodHandle</span>(<span style="color: rgb(184, 191, 198);">THREAD</span>, <span style="color: rgb(184, 191, 198);">m</span>); <span style="color: rgb(218, 146, 74);">// 将调用方法包装为methodHandle指针，方便计算（读者不需要研究这是啥，就是C++的运算符重载而已，这里MethodHandle就等于Method* m指针，而该方法将是我们后面需要执行的方法，也即invokedynamic字节码指令执行的最后的call_method）</span></p>
<p>&nbsp;}</p>
<p>}</p>
<p>&nbsp;<span style="color: rgb(218, 146, 74);">// 链接失败</span></p>
<p>&nbsp;<span style="color: rgb(184, 191, 198);">THROW_MSG_</span>(<span style="color: rgb(184, 191, 198);">vmSymbols::java_lang_LinkageError</span>(), <span style="color: rgb(210, 107, 107);">"bad value from MethodHandleNatives"</span>, <span style="color: rgb(184, 191, 198);">empty</span>);</p>
<p>&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">empty</span>;</p>
<p>}</p>
<p>那么很容易就能理解了，直接进入Java的java.lang.invoke.MethodHandleNatives::linkCallSite方法。该方法我们看到最终返回一个描述调用信息的MemberName对象。</p>
<p><span style="color: rgb(200, 143, 208);">static</span> <span style="color: rgb(184, 191, 198);">MemberName</span> <span style="color: rgb(141, 141, 240);">linkCallSite</span>(<span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">callerObj</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">bootstrapMethodObj</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">nameObj</span>, <span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">typeObj</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">staticArguments</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">Object</span>[] <span style="color: rgb(184, 191, 198);">appendixResult</span>) {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MethodHandle</span> <span style="color: rgb(184, 191, 198);">bootstrapMethod</span> <span style="color: rgb(184, 191, 198);">=</span> (<span style="color: rgb(184, 191, 198);">MethodHandle</span>)<span style="color: rgb(184, 191, 198);">bootstrapMethodObj</span>; <span style="color: rgb(218, 146, 74);">// 指向我们刚才提到的中间代码</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span> <span style="color: rgb(184, 191, 198);">caller</span> <span style="color: rgb(184, 191, 198);">=</span> (<span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span>)<span style="color: rgb(184, 191, 198);">callerObj</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">String</span> <span style="color: rgb(184, 191, 198);">name</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">nameObj</span>.<span style="color: rgb(184, 191, 198);">toString</span>().<span style="color: rgb(184, 191, 198);">intern</span>();</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MethodType</span> <span style="color: rgb(184, 191, 198);">type</span> <span style="color: rgb(184, 191, 198);">=</span> (<span style="color: rgb(184, 191, 198);">MethodType</span>)<span style="color: rgb(184, 191, 198);">typeObj</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">!TRACE_METHOD_LINKAGE</span>) <span style="color: rgb(218, 146, 74);">// 我们不对方法链接进行追踪，所以直接看这里</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">linkCallSiteImpl</span>(<span style="color: rgb(184, 191, 198);">caller</span>, <span style="color: rgb(184, 191, 198);">bootstrapMethod</span>, <span style="color: rgb(184, 191, 198);">name</span>, <span style="color: rgb(184, 191, 198);">type</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">staticArguments</span>, <span style="color: rgb(184, 191, 198);">appendixResult</span>);</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">linkCallSiteTracing</span>(<span style="color: rgb(184, 191, 198);">caller</span>, <span style="color: rgb(184, 191, 198);">bootstrapMethod</span>, <span style="color: rgb(184, 191, 198);">name</span>, <span style="color: rgb(184, 191, 198);">type</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">staticArguments</span>, <span style="color: rgb(184, 191, 198);">appendixResult</span>);</p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(200, 143, 208);">static</span> <span style="color: rgb(184, 191, 198);">MemberName</span> <span style="color: rgb(141, 141, 240);">linkCallSiteImpl</span>(<span style="color: rgb(184, 191, 198);">Class&lt;?&gt;</span> <span style="color: rgb(184, 191, 198);">caller</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MethodHandle</span> <span style="color: rgb(184, 191, 198);">bootstrapMethod</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">String</span> <span style="color: rgb(184, 191, 198);">name</span>, <span style="color: rgb(184, 191, 198);">MethodType</span> <span style="color: rgb(184, 191, 198);">type</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">Object</span> <span style="color: rgb(184, 191, 198);">staticArguments</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">Object</span>[] <span style="color: rgb(184, 191, 198);">appendixResult</span>) {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">CallSite</span> <span style="color: rgb(184, 191, 198);">callSite</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">CallSite</span>.<span style="color: rgb(184, 191, 198);">makeSite</span>(<span style="color: rgb(184, 191, 198);">bootstrapMethod</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">name</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">type</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">staticArguments</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">caller</span>); <span style="color: rgb(218, 146, 74);">// 调用MethodHandle指向的方法，这里就是LambdaMetafactory.metafactory方法，该方法将返回一个ConstantCallSite，我们看到这里将ConstantCallSite内部的dynamicInvoker对象放入到了appendixResult数组中</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">if</span> (<span style="color: rgb(184, 191, 198);">callSite</span> <span style="color: rgb(200, 143, 208);">instanceof</span> <span style="color: rgb(184, 191, 198);">ConstantCallSite</span>) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">appendixResult</span>[<span style="color: rgb(100, 171, 143);">0</span>] <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">callSite</span>.<span style="color: rgb(184, 191, 198);">dynamicInvoker</span>();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">Invokers</span>.<span style="color: rgb(184, 191, 198);">linkToTargetMethod</span>(<span style="color: rgb(184, 191, 198);">type</span>); <span style="color: rgb(218, 146, 74);">// 根据方法类型，构建一个MemberName对象</span></p>
<p>&nbsp;} <span style="color: rgb(200, 143, 208);">else</span> { <span style="color: rgb(218, 146, 74);">// 其他类型不考虑，我们这里只看ConstantCallSite</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">appendixResult</span>[<span style="color: rgb(100, 171, 143);">0</span>] <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(184, 191, 198);">callSite</span>;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">Invokers</span>.<span style="color: rgb(184, 191, 198);">linkToCallSiteMethod</span>(<span style="color: rgb(184, 191, 198);">type</span>);</p>
<p>&nbsp;}</p>
<p>}</p>
<p>我们先了解到这里即可，先看看LambdaMetafactory.metafactory干了什么，如何创建CallSite对象。我们看到最终创建了一个ConstantCallSite对象并返回。</p>
<p><span style="color: rgb(200, 143, 208);">public</span> <span style="color: rgb(200, 143, 208);">static</span> <span style="color: rgb(184, 191, 198);">CallSite</span> <span style="color: rgb(141, 141, 240);">metafactory</span>(<span style="color: rgb(184, 191, 198);">MethodHandles</span>.<span style="color: rgb(184, 191, 198);">Lookup</span> <span style="color: rgb(184, 191, 198);">caller</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(28, 198, 133);">String</span> <span style="color: rgb(184, 191, 198);">invokedName</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MethodType</span> <span style="color: rgb(184, 191, 198);">invokedType</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MethodType</span> <span style="color: rgb(184, 191, 198);">samMethodType</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MethodHandle</span> <span style="color: rgb(184, 191, 198);">implMethod</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">MethodType</span> <span style="color: rgb(184, 191, 198);">instantiatedMethodType</span>)</p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">throws</span> <span style="color: rgb(184, 191, 198);">LambdaConversionException</span> {</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">AbstractValidatingLambdaMetafactory</span> <span style="color: rgb(184, 191, 198);">mf</span>;</p>
<p>&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">mf</span> <span style="color: rgb(184, 191, 198);">=</span> <span style="color: rgb(200, 143, 208);">new</span> <span style="color: rgb(184, 191, 198);">InnerClassLambdaMetafactory</span>(<span style="color: rgb(184, 191, 198);">caller</span>, <span style="color: rgb(184, 191, 198);">invokedType</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">invokedName</span>, <span style="color: rgb(184, 191, 198);">samMethodType</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(184, 191, 198);">implMethod</span>, <span style="color: rgb(184, 191, 198);">instantiatedMethodType</span>,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(132, 182, 203);">false</span>, <span style="color: rgb(184, 191, 198);">EMPTY_CLASS_ARRAY</span>, <span style="color: rgb(184, 191, 198);">EMPTY_MT_ARRAY</span>); <span style="color: rgb(218, 146, 74);">// 构建内部类LambdaMetaFactory对象</span></p>
<p>&nbsp;&nbsp;<span style="color: rgb(200, 143, 208);">return</span> <span style="color: rgb(184, 191, 198);">mf</span>.<span style="color: rgb(184, 191, 198);">buildCallSite</span>(); <span style="color: rgb(218, 146, 74);">// 构建CallSite</span></p>
<p>}</p>
<p>​</p>
<p><span style="color: rgb(184, 191, 198);">CallSite</span> <span style="color: rgb(141, 141, 240);">buildCallSite</span>() <span style="color: rgb(200, 143, 208);">throws</span> <span style="color: rgb(184, 191, 198);">LambdaConversionException</span> {</p></p>
</body>
</html>